---
title: "Fracture Search"
date: 2023-05-06T22:30:00+08:00
draft: true
tags: ["tutorial"]
summary: "笨方塊不會搜索，燒雞"
---

爆雷提醒：以下的內容含有 OI 題，請小心服用。  

### Warm-up

> 有 $N$ 個商品，第 $i$ 個商品的價格是 $a_i$，其中每個商品可以選或者不選，求出前 $K$ 便宜的方案。  
> $N \leq 40, K \leq 10^5$  

這個問題可以單純透過二分搜並且折半枚舉計算可能性數量，就能把前 $K$ 小的答案都回溯出來，時間複雜度是 $\mathcal O(2^N \log \sum a_i)$（可以做到 $\mathcal O(K \log \sum a_i)$），對於這一個技巧有個很好的筆記已經統整出來了：dreamoon 大神所寫的[從枚舉到 $K$ 短路](https://zhuanlan.zhihu.com/p/56269536)。  

不過，Fracture Search 是用來解決限制更為複雜的題目。  

### $k$-th MST  

> 有一張 $N$ 點 $M$ 邊的簡單圖，求出前 $K$ 小的生成樹。  

之前我在逛 Codeforces 時，有一個 [comment](https://codeforces.com/blog/entry/71616?#comment-559617) 給出了一個作法，但是在說明這個做法之前，先想想這個問題：  

> 有一張 $N$ 點 $K$ 邊的簡單圖，求出第 $2$ 小的生成樹。  

這題應該是一題經典的題目，先求出 MST，然後枚舉不在這個 MST 上的邊，接下來把這個邊上的路徑中選最大的拔掉，就得到第 $2$ 小的生成樹了。  

這個作者的方法就是把這件事情給一般化：  
假如我們有前 $i - 1$ 小的生成樹了，那第 $i$ 小的生成樹應該會跟這前 $i - 1$ 棵的樹差某一條邊。  

因此這個算法大致上就是先蓋好一個 MST，然後不斷對每個生成樹，去加一條邊然後拔掉形成環上最大的邊，接者把這 $i \times (M - N + 1)$ 棵新的生成樹蓋出來然後與前 $i$ 個比對，把沒有重複的且最小權的加進去，時間複雜度是 $\mathcal O(MK^2\log N)$。  

先不論這個算法是否能通過，很大的問題是他是錯的，考慮以下的反例：  

{{< figure src="/images/fracture-search/counterexample.webp" width="300" >}}

|$k$-th|生成樹|替換邊之後的次小生成樹|
|-|-|-|
|$1$|$\\{1, 2, 3\\}$|$\\{1, 2, 4\\}$|
|$2$|$\\{1, 2, 4\\}$|$\\{1, 2, 3\\}$|
|$3$|

顯然遇到大問題了，也就是第 3 個應該要有一棵樹才對。  
修正這個演算法有很多種方法，其中一種就是直接枚舉所有要拆掉的邊，時間複雜度是 $\mathcal O(NMK^2)$。  

現在我們要來解決這個演算法嘗試解決的東西：**去掉重複的答案**，  
如果我們在搜索的時候不斷遇到重複的答案，要不是會失去正確性，就可能會花很多時間在去除這樣的資料，  
Fracture Search 就是用來處理這樣的問題，對 Fracture Search 的算法，都具有這樣的樣子：  

定義一個搜尋空間 $S$ 表示一個集合包含了很多可行的解，維護一個集合 $U$，而 $U$ 當中有很多搜尋空間。  
不斷的把 $U$ 當中所有搜尋空間中最佳解最好的解 $s$ 拿出來，在這個搜尋空間 $S^\*$ 中，把 $S^\*$ 分割成很多個子空間 $S_1, S_2, \cdots, S_k$，滿足  
1. $\bigcup S_i = S^\* \backslash \\{s\\}$  
2. $S_i \cap S_j = \varnothing \quad (i \neq j)$  

當然分割的方法不是隨便給的，其中 $S_i$ 最好是我們好處理的東西，  

對於這題，套 Fracture Search 的時候，我們先定義一個搜尋空間是用一個陣列來表達，第 $i$ 位如果是 
- `1` 表示一定要用第 $i$ 個元素，  
- `-1` 表示一定不能用第 $i$ 個元素，  
- `0` 表示自由決定。  

套在這個問題上面，演算法就如下面所示：  
首先，開一棵 heap，heap 裡面所放的每個元素是一個長度為 $M$ 的陣列，每個陣列的價值被定義成在這個條件限制下的 MST 權重，而 heap 頂端是當前權重最小的陣列。  
一開始在 heap 丟進去一個全部都是 `0` 的陣列，然後重複做這件事 $K$ 次：  
1. 令 $A$ 是 heap 頂端的陣列，把這個陣列取出來，第 $i$ 次做這件事所取得的就是第 $i$ 小的生成樹。  
2. 考慮 $A$ 條件限制下那些自由決定的邊，隨便為他們訂一個順序 $e_1, e_2, \cdots, e_k$。  
3. 對剩下的解來講，一定有一條邊會與這 $e_1, e_2, \cdots, e_k$ 的其中一個不一樣，我們把第一個不一樣的抓出來，  
   所以對所有 $e_i$，建立這樣的搜索空間：  
   原本在 $A$ 當中有限制的維持限制，而所有 $e_j \quad (j < i)$ 設成 `1`（必須使用），$e_i$ 設為 `-1`（不能使用），剩下的設為 `0`。  

預先把所有邊排序好，這樣每次抓出一個新的解的時候，需要重新計算最多 $N - 1$ 個搜索空間的 MST，用 $\mathcal O(M\alpha(N))$ 的 MST 演算法，總時間複雜度是 $\mathcal O(KNM\alpha(N) + K\log K)$。  

### $k$-th Shortest Simple Path
或許有人已經會 $k$-短路了（這題似乎有噁噁資料結構跟酷酷二分搜的方法可以做），那 $k$-短簡單路呢？  

> 有一張 $N$ 點 $M$ 邊的有向圖，求出 $s$ 到 $t$ 前 $K$ 短的簡單路徑。  

套上同樣的 Fracture Search 之後，現在的問題是給定一個任意的邊集，很難快速的找到一條最短的簡單路通過這些邊。
Fracture Search 就這樣止步了嗎？當然不會，我們剛剛的算法還有一個地方沒有用到：

- 隨便為他們訂一個順序 $e_1, e_2, \cdots, e_k$。  

我們只要把這段改成

- 按照路徑上的順序排序為 $e_1, e_2, \cdots, e_k$。  



預先把所有邊排序好，這樣每次抓出一個新的解的時候，需要重新計算最多 $N - 1$ 個搜索空間的 MST，用 $\mathcal O(M\alpha(N))$ 的 MST 演算法，總時間複雜度是 $\mathcal O(KNM\alpha(N) + K\log K)$。  

